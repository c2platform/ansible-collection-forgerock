---
- name: Create owner
  user:
    name: "{{ amster_owner }}"
    shell: /bin/bash
    system: true

- name: Create home
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    mode: 0755
  with_items:
    - "{{ amster_home }}"
    - "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}"

- name: Download zip file
  get_url:
    url: "{{ amster_versions[amster_version]['url'] }}"
    dest: "{{ amster_download_dir }}/{{ amster_versions[amster_version]['url']|basename }}"
    checksum: "{{ amster_versions[amster_version]['checksum'] }}"
    timeout: 600
    mode: 1373
  register: get_url_result
  until: get_url_result is succeeded

- name: Unzip the zipfile
  unarchive:
    dest:  "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}"
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    remote_src: yes
    src: "{{ amster_download_dir }}/{{ amster_versions[amster_version]['url']|basename }}"

- name: Stat openamcfg dir  (in /opt/am, not /opt/amster!) to prevent running twice
  stat:
    path: "{{ am_home }}/{{ am_version }}/openamcfg"
  register: amster_has_run

- name: Create config.amster script file
  template:
    src: config.amster.j2
    dest: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}/config.amster"
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    mode: 0755
# Note that we preferred having config.amster in a muli-line readable format with \ concatenation, but even without Ansible
# this proved too buggy in Amster 6.5. Hence the looooong line :-(
# Also note that --cookieDomain  is for now hardcoded to the  DNS name of the AM machine. That is not the proper way
# for post-MVP but the whole .amster file logistics change then, with part input from BKWI git (file which are part of a CI-CD Java release)
# Hence we left out making an extra Ansible variable for it.

- name: Confirm AM up
  uri:
    url: "http://{{ amster_install_am['serverURL']  }}:8080/am"
    status_code: 200
  register: am_up_result
  until: am_up_result.status == 200
  retries: 10
  delay: 10 # seconds
  when: not amster_has_run.stat.exists
#  This is a waitloop until AM web interface, assumed needed for the Amster REST calls, is up and running


- name: check ldap connection to ds (check is more or less a random one from within ds role)
# The actual check on the result is in the 'when' clause for the ldap tool, see below.
# Last parameter is dashless hence hardcoded here
  shell:  "./ldapsearch  {{ dsc_user_reports_inquire|c2platform.forgerock.ds_cmd }} objectclass=person"
  become: yes
  become_user: forgerock
  args:
    chdir: "{{ ds_home }}/{{ ds_home|basename }}-{{ ds_version }}/bin"
  register: user_reports_inquire
  ignore_errors: yes

- name: Exit if no running DS service found
  when: user_reports_inquire is search("No Such Entry")
  fail: msg="The DS server needed to provision using Amster is not running"



- name: execute amster if not yet done
  command: "./amster config.amster"
  register: task_register_var
  become: yes
  become_user: "{{ am_owner }}"
  args:
    chdir: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}/"
  when: not amster_has_run.stat.exists

- name: debug task_register_var
  debug:
    msg: "{{ task_register_var }}"
