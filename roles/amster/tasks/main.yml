---
- name: Create owner
  user:
    name: "{{ amster_owner }}"
    shell: /bin/bash
    system: true

- name: Create home
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    mode: 0755
  with_items:
    - "{{ amster_home }}"
    - "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}"

- name: Download zip file
  get_url:
    url: "{{ amster_versions[amster_version]['url'] }}"
    dest: "{{ amster_download_dir }}/{{ amster_versions[amster_version]['url']|basename }}"
    checksum: "{{ amster_versions[amster_version]['checksum'] }}"
    timeout: 600
    mode: 1373
  register: get_url_result
  until: get_url_result is succeeded

- name: Unzip the zipfile
  unarchive:
    dest:  "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}"
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    remote_src: yes
    src: "{{ amster_download_dir }}/{{ amster_versions[amster_version]['url']|basename }}"

- name: Stat openamcfg dir  (in /opt/am, not /opt/amster!) to prevent running twice
  stat:
    path: "{{ am_home }}/{{ am_version }}/openamcfg"
  register: amster_has_run

- name: Create config.amster script file
  template:
    src: config.amster.j2
    dest: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}/config.amster"
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    mode: 0755
# Note that we preferred having config.amster in a muli-line readable format with \ concatenation, but even without Ansible
# this proved too buggy in Amster 6.5. Hence the looooong line :-(
# Also note that --cookieDomain  is for now hardcoded to the  DNS name of the AM machine. That is not the proper way
# for post-MVP but the whole .amster file logistics change then, with part input from BKWI git (file which are part of a CI-CD Java release)
# Hence we left out making an extra Ansible variable for it.

- name: Confirm AM up
  uri:
    url: "http://{{ amster_install_am['serverURL']  }}:8080/am"
    status_code: 200
  register: am_up_result
  until: am_up_result.status == 200
  retries: 10
  delay: 10 # seconds
  when: not amster_has_run.stat.exists
#  This is a waitloop until AM web interface, assumed needed for the Amster REST calls, is up and running

- name: Create DSping bash script file
  template:
    src: DSping.sh.j2
    dest: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}/DSping.sh"
    owner: "{{ am_owner }}"
    group: "{{ am_group }}"
    mode:  a+rwx
# The outcome if ldapsearch cannot reach DS node is "ldap_sasl_bind(SIMPLE): Can't contact LDAP server (-1)"
# But as that is an error, that even came after grepping it; a known limitation of ldapsearch
# Hence at start of  the .sh we dispose of all error, now it's either empty grep or success 


- name: Check connection to DS server
  shell: if ./DSping.sh | grep -q "alive"; then echo "yes"; else echo "no" ;fi  
  register: ldapresult
  until: ldapresult.stdout == "yes" 
  retries: 5
  become: yes
  ignore_errors: yes
  become_user: "{{ am_owner }}"
  args:
    chdir: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}"

# Ignore_errors is needed otherwise the fail makes the execution stop here already

- name: Exit if no running DS service found
  fail: msg="The DS server needed to provision using Amster is not running"
  when: ldapresult.stdout == "no"  

# So this would happen when 5 retries gave the same result which is negative


- name: execute amster if not yet done 
  command: "./amster config.amster"
  register: task_register_var
  become: yes
  become_user: "{{ am_owner }}"
  args:
    chdir: "{{ amster_home }}/{{ amster_home|basename }}-{{ amster_version }}/"
  when: not amster_has_run.stat.exists

- name: debug task_register_var
  debug:
    msg: "{{ task_register_var }}"
