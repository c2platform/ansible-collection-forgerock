println 104

println green ("INFO: IG J2EE Agent parameters")
agentName = 'suwinet-agent'
igFQDN='{{ amster_igfqdn }}'
igPORT='443'
igPROTO='https'
igREMOTELOGFILE='amAgent_suwinet_agent_8443.log'
amFQDN='{{ amster_amfqdn }}'
amURI='acs'
amPROTO='https'
amPORT='443'
// Note $realmName is already set in 103, which is executed prior to this

BODY="""
{
      "userDataCachePollingTime" : 1,
      "serviceDataCacheTime" : 1,
      "loginProbeTimeout" : 2000,
      "loginUrlPrioritized" : true,
      "policyClientResourceComparators" : "serviceType=iPlanetAMWebAgentService|class=com.sun.identity.policy.plugins.HttpURLResourceName|wildcard=*|delimiter=/|caseSensitive=false",
      "policyEvaluationApplication" : "iPlanetAMWebAgentService",
      "policyEvaluationRealm" : "/$realmName",
      "policyClientCacheMode" : "self",
      "authServiceHost" : "$amFQDN",
      "conditionalLogoutUrl" : [ "" ],
      "logoutProbeTimeout" : 2000,
      "amLogoutUrl" : [ "$amPROTO://$amFQDN:$amPORT/$amURI/UI/Logout" ],
      "clientPollingPeriod" : 180,
      "amLoginUrl" : [ "" ],
      "policyActionBooleanValues" : "iPlanetAMWebAgentService|GET|allow|deny:iPlanetAMWebAgentService|POST|allow|deny:iPlanetAMWebAgentService|PUT|allow|deny:iPlanetAMWebAgentService|DELETE|allow|deny:iPlanetAMWebAgentService|HEAD|allow|deny:iPlanetAMWebAgentService|OPTIONS|allow|deny:iPlanetAMWebAgentService|PATCH|allow|deny",
      "policyClientClockSkew" : 10,
      "urlPolicyEnvPostParameters" : [ "" ],
      "useRedirectForCompositeAdvice" : false,
      "urlPolicyEnvJsessionParameters" : [ "" ],
      "probeLoginUrl" : true,
      "policyClientPollingInterval" : 3,
      "urlPolicyEnvGetParameters" : [ "" ],
      "authServiceProtocol" : "http",
      "userDataCacheNotifications" : true,
      "policyNotifications" : true,
      "serviceDataCacheNotifications" : true,
      "logoutUrlPrioritized" : true,
      "probeLogoutUrl" : true,
      "authServicePort" : $amPORT,
      "enableClientPolling" : false,
      "conditionalLoginUrl" : [ "" ],
      "redirectAttemptLimit" : 0,
      "auditLogLocation" : "REMOTE",
      "fqdnMapping" : { },
      "filterMode" : { "" : "ALL" },
      "remoteLogFilename" : "$igREMOTELOGFILE",
      "userAttributeName" : "uid",
      "userTokenName" : "UserToken",
      "loginAttemptLimit" : 0,
      "agentgroup" : null,
      "customResponseHeader" : { },
      "fqdnCheck" : false,
      "status" : "Active",
      "localAuditLogRotation" : false,
      "webSocketConnectionIntervalInMinutes" : 30,
      "agentConfigChangeNotificationsEnabled" : true,
      "userpassword" : "{{ amster_bindusrpwd }}",
      "httpSessionBinding" : true,
      "userPrincipalFlag" : false,
      "configurationReloadInterval" : 0,
      "auditAccessType" : "LOG_NONE",
      "cdssoRootUrl" : [ "agentRootURL=$igPROTO://$igFQDN:$igPORT" ],
      "debugLevel" : "error",
      "fqdnDefault" : "$igFQDN",
      "agentNotificationUrl" : "$amPROTO://$amFQDN:$amPORT/$amURI/agentapp/notification",
      "localAuditRotationSize" : 52428800,
      "jwtName" : "am-auth-jwt",
      "userMappingMode" : "USER_ID",
      "repositoryLocation" : "centralized",
      "notEnforcedUrisCacheSize" : 1000,
      "loginFormUri" : [ "" ],
      "notEnforcedRuleCompoundSeparator" : "|",
      "useInternalLogin" : true,
      "loginContentFile" : "FormLoginContent.txt",
      "logoutEntryUri" : { },
      "profileAttributeMap" : { },
      "headerAttributeDateFormat" : "EEE, d MMM yyyy hh:mm:ss z",
      "notEnforcedUrisRefreshSessionIdleTime" : false,
      "shortenedPrivilegeAttributeValues" : false,
      "profileAttributeFetchMode" : "NONE",
      "privilegedSessionAttribute" : [ "" ],
      "applicationLogoutUris" : { },
      "customAuthenticationHandlers" : { },
      "responseAttributeMap" : { },
      "responseAttributeFetchMode" : "NONE",
      "privilegedAttributesToLowerCase" : { "Role":"false","Group":"false" },
      "cookieAttributeMultiValueSeparator" : "|",
      "loginErrorUri" : [ "" ],
      "customVerificationHandlers" : { },
      "privilegedAttributeType" : [ "Group", "Role"  ],
      "sessionAttributeFetchMode" : "NONE",
      "cookieAttributeUrlEncoded" : true,
      "invertNotEnforcedUris" : false,
      "continuousSecurityHeaders" : { },
      "privilegedAttributeMap" : { },
      "customLogoutHandlers" : { },
      "notEnforcedIpsCacheSize" : 1000,
      "applicationLogoutHandlers" : { },
      "logoutRequestParameters" : { },
      "notEnforcedIpsCacheEnabled" : true,
      "resourceAccessDeniedUri" : { },
      "defaultPrivilegedAttributes" : [ "AUTHENTICATED_USERS" ],
      "continuousSecurityCookies" : { },
      "invertNotEnforcedIps" : false,
      "notEnforcedUrisCacheEnabled" : true,
      "notEnforcedUris" : [ "" ],
      "notEnforcedIps" : [ "" ],
      "privilegedAttributeMappingEnabled" : true,
      "logoutIntrospection" : false,
      "sessionAttributeMap" : { },
      "postDataPreserveCacheEntryMaxEntries" : 1000,
      "alternativeAgentHostname" : null,
      "webServiceInternalErrorContentFile" : "WSInternalErrorContent.txt",
      "missingPostDataPreservationEntryUri" : [ "" ],
      "webServiceProcessGetEnabled" : true,
      "webServiceEnabled" : false,
      "alternativeAgentProtocol" : null,
      "webServiceAuthorizationErrorContentFile" : "WSAuthErrorContent.txt",
      "clientHostnameHeader" : null,
      "postDataPreserveCacheEntryMaxTotalSizeMb" : -1,
      "webServiceResponseProcessor" : null,
      "webServiceAuthenticator" : null,
      "possibleXssCodeElements" : [ "" ],
      "webServiceEndpoints" : [ "" ],
      "postDataCacheTtl" : 300000,
      "postDataPreservation" : false,
      "postDataStickySessionKeyValue" : null,
      "xssDetectionRedirectUri" : { },
      "customProperties" : [ ],
      "postDataStickySessionMode" : "URL",
      "jbossWebAuthenticationAvailable" : false,
      "alternativeAgentPort" : null,
      "clientIpHeader" : null,
      "legacyUserAgentList" : [ "Mozilla/4.7*" ],
      "encryptionProvider" : "com.iplanet.services.util.JCEEncryption",
      "localeLanguage" : "en",
      "portCheckFile" : "PortCheckContent.txt",
      "legacyRedirectUri" : "/agentapp/sunwLegacySupportURI",
      "ignorePathInfo" : false,
      "localeCountry" : "US",
      "gotoParameterName" : "goto",
      "portCheckSetting" : { "$amPORT":"$amPROTO" },
      "portCheckEnabled" : false,
      "legacyUserAgentSupport" : false,
      "bypassPrincipalList" : [ "" ],
      "cookieResetDomains" : {  },
      "cdssoTrustedIdProvider" : [ "https://{{ amster_igfqdn }}/am/cdcservlet" ],
      "cdsso" : false,
      "cdssoUrls" : [ "https://{{ amster_igfqdn }}/am/cdcservlet" ],
      "cdssoDomainList" : [ "" ],
      "cdssoRedirectUri" : "/agentapp/sunwCDSSORedirectURI",
      "cookieResetNames" : [ "" ],
      "cookieResetEnabled" : false,
      "cookieResetPaths" : { },
      "amCookieName" : "samb",
      "ssoCacheEnabled" : true,
      "cdssoSecureCookies" : false,
      "cdssoClockSkew" : 0 }
}
""";

// SBP situation: Chef runs this script only when something is changed, so simply create the j2ee agent when it doesn't exist and otherwise update it
// VIPS situation: more or less same, Ansible Amster play detects whether 
// initial install-openam was done and afterwards if 400-deck, 100-deck and 201-deck scripts have run.
// So if that check determines the current versions of these decks do not match the state (export-config),
// it'll re-run the decks and then this 104 script is also run.
// TODO: Ops procedures to make sure that the Ansible play _is_ run after something has changed!

if(isNull(eval("read J2eeAgents --realm $realmName --id $agentName"))){
      if(isNull(eval("create J2eeAgents --realm $realmName --id $agentName --body '$BODY'"))) {
            println red("Error creating J2eeAgent $agentName in realm $realmName");
      } else {
            println green("J2eeAgent $agentName in realm $realmName created");
      }
} else {
      if(isNull(eval("update J2eeAgents --realm $realmName --id $agentName --body '$BODY'"))) {
            println red("Error updating J2eeAgent $agentName in realm $realmName");
      } else {
            println green("J2eeAgent $agentName in realm $realmName updated");
      }
}
